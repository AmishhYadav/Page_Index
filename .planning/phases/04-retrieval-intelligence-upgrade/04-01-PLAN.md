# Plan 04-01: Hybrid Retrieval (Vector + BM25)

## Goal
Replace pure vector search with a hybrid retrieval pipeline that fuses dense (Qdrant) and sparse (BM25) signals using Reciprocal Rank Fusion.

<tasks>
  <task id="1" title="Add BM25 Index to PostgreSQL">
    <description>Add a `tsvector` column to the `sections` table via Alembic migration. Create a GIN index for full-text search. Populate the column from `section.content` using `to_tsvector('english', content)`.</description>
  </task>
  <task id="2" title="Implement BM25Retriever">
    <description>Create `app/services/bm25_retriever.py`. Implement `search(query, top_k)` that:
    1. Converts the query to a `tsquery`.
    2. Queries Postgres using `ts_rank_cd` for BM25-like scoring.
    3. Returns ranked section IDs with scores.</description>
  </task>
  <task id="3" title="Implement Reciprocal Rank Fusion">
    <description>Create `app/services/fusion.py`. Implement `rrf_fuse(vector_results, bm25_results, k=60)` that:
    1. Calculates `1 / (k + rank)` for each result in each list.
    2. Sums scores for sections appearing in both lists.
    3. Returns a unified ranked list.</description>
  </task>
  <task id="4" title="Refactor RetrievalService">
    <description>Update `app/services/retrieval.py` to call both Qdrant and BM25 retriever, then fuse results before the Postgres hierarchy join.</description>
  </task>
</tasks>

<verification>
1. BM25 retriever returns results for exact keyword matches that vector search misses.
2. RRF fusion produces a combined ranking that outperforms either signal alone.
3. Existing `/ask` endpoint works unchanged (backward compatible).
</verification>

<must_haves>
- `tsvector` column populated on ingestion (update `IngestionService`).
- Configurable BM25/vector weights via `config.py`.
- BM25 can be disabled via config (graceful fallback to vector-only).
</must_haves>
